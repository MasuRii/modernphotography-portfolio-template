---
import DemoLink from '../demo/DemoLink.astro';
import DemoButton from '../demo/DemoButton.astro';
// Lightbox.astro
---

<div
  id="lightbox"
  role="dialog"
  aria-modal="true"
  aria-label="Image Gallery"
  class="fixed inset-0 z-[100] flex items-center justify-center bg-[rgba(10,10,10,0.95)] backdrop-blur-xl opacity-0 pointer-events-none transition-opacity duration-300 ease-out"
  tabindex="-1"
>
  <!-- Top Bar -->
  <div class="absolute top-0 left-0 right-0 p-6 flex justify-between items-start z-[110]">
    <div class="flex items-center gap-4">
      <span id="lightbox-counter" class="text-white/60 font-mono text-sm tracking-widest"></span>
    </div>

    <div class="flex items-center gap-4 pr-12">
        <DemoButton 
            feature="Download Image" 
            demoMessage="Downloading high-res images is disabled in demo mode."
            class="text-white/70 hover:text-white p-2 transition-colors"
            aria-label="Download"
        >
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
        </DemoButton>
        <DemoLink 
            href="#" 
            id="lightbox-share"
            class="text-white/70 hover:text-white p-2 transition-colors"
            aria-label="Share"
        >
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line></svg>
        </DemoLink>
    </div>
  </div>

  <!-- Close Button -->
  <button
    id="lightbox-close"
    class="absolute top-6 right-6 text-white/70 hover:text-white z-[110] p-2 focus:outline-none focus:ring-1 focus:ring-white/50 rounded-full transition-colors duration-200"
    aria-label="Close lightbox"
  >
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <line x1="18" y1="6" x2="6" y2="18"></line>
      <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
  </button>

  <!-- Prev Button -->
  <button
    id="lightbox-prev"
    class="absolute left-4 top-1/2 -translate-y-1/2 text-white/70 hover:text-white z-[110] p-4 focus:outline-none focus:ring-1 focus:ring-white/50 rounded-full transition-colors duration-200 hidden md:block"
    aria-label="Previous image"
  >
    <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="15 18 9 12 15 6"></polyline>
    </svg>
  </button>

  <!-- Next Button -->
  <button
    id="lightbox-next"
    class="absolute right-4 top-1/2 -translate-y-1/2 text-white/70 hover:text-white z-[110] p-4 focus:outline-none focus:ring-1 focus:ring-white/50 rounded-full transition-colors duration-200 hidden md:block"
    aria-label="Next image"
  >
    <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </button>

  <!-- Main Image Container -->
  <div class="relative w-full h-full max-w-[90vw] max-h-[90vh] flex items-center justify-center overflow-hidden">
    <div id="lightbox-image-wrapper" class="relative w-full h-full flex items-center justify-center overflow-hidden">
      <img
        id="lightbox-image"
        src=""
        alt=""
        class="max-w-full max-h-full object-contain shadow-2xl select-none transition-transform duration-200 ease-out cursor-zoom-in touch-none"
        draggable="false"
      />
    </div>
    
    <!-- Caption Overlay -->
    <div
      id="lightbox-caption-container"
      class="absolute bottom-0 left-0 right-0 p-8 text-center text-white bg-gradient-to-t from-black/80 to-transparent pointer-events-none opacity-0 transition-opacity duration-300 delay-150 flex flex-col items-center"
    >
        <span id="lightbox-category" class="block text-xs font-light uppercase tracking-[0.2em] text-neutral-300 mb-2"></span>
        <h2 id="lightbox-title" class="text-xl md:text-2xl font-serif font-normal tracking-wide"></h2>
        <p id="lightbox-caption" class="text-sm font-light text-neutral-400 mt-2 max-w-2xl mx-auto hidden"></p>
        
        <!-- EXIF Data -->
        <div id="lightbox-exif" class="mt-4 flex flex-wrap justify-center gap-4 text-xs font-mono text-neutral-500 hidden">
            <!-- Populated via JS -->
        </div>
    </div>
  </div>
</div>

<script>
  import { isLightboxOpen, currentIndex, lightboxImages, closeLightbox, nextImage, prevImage } from '../../store/lightbox';
  
  const lightbox = document.getElementById('lightbox');
  const imgElement = document.getElementById('lightbox-image') as HTMLImageElement;
  const titleElement = document.getElementById('lightbox-title');
  const categoryElement = document.getElementById('lightbox-category');
  const captionElement = document.getElementById('lightbox-caption');
  const exifElement = document.getElementById('lightbox-exif');
  const counterElement = document.getElementById('lightbox-counter');
  const shareLink = document.getElementById('lightbox-share') as HTMLAnchorElement;
  const captionContainer = document.getElementById('lightbox-caption-container');
  const closeBtn = document.getElementById('lightbox-close');
  const prevBtn = document.getElementById('lightbox-prev');
  const nextBtn = document.getElementById('lightbox-next');
  const imageWrapper = document.getElementById('lightbox-image-wrapper');

  // Zoom State
  let isZoomed = false;
  let currentScale = 1;
  let translateX = 0;
  let translateY = 0;
  let startX = 0;
  let startY = 0;
  let isDragging = false;
  
  // Touch Zoom State
  let initialDistance = 0;

  function resetZoom() {
    isZoomed = false;
    currentScale = 1;
    translateX = 0;
    translateY = 0;
    updateImageTransform();
    if (imgElement) {
        imgElement.style.cursor = 'zoom-in';
        imgElement.classList.remove('cursor-grab', 'cursor-grabbing');
    }
  }

  function updateImageTransform() {
    if (imgElement) {
        imgElement.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentScale})`;
    }
  }

  function toggleZoom(e: MouseEvent | TouchEvent) {
    if (isZoomed) {
        resetZoom();
    } else {
        isZoomed = true;
        currentScale = 2.5; // Zoom level
        
        // Calculate click position relative to image to zoom towards that point
        // For simplicity in this iteration, we just zoom to center or clamp later
        // A simple centered zoom is safer for the first pass
        
        if (imgElement) {
            imgElement.style.cursor = 'zoom-out';
            imgElement.classList.add('cursor-grab');
        }
        updateImageTransform();
    }
    e.stopPropagation();
  }

  function handlePointerDown(e: MouseEvent | TouchEvent) {
    if (!isZoomed) return;
    isDragging = true;
    
    let clientX = 0;
    let clientY = 0;

    if ('touches' in e && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else if ('clientX' in e) {
        clientX = (e as MouseEvent).clientX;
        clientY = (e as MouseEvent).clientY;
    } else {
        return;
    }
    
    startX = clientX - translateX;
    startY = clientY - translateY;
    
    if (imgElement) imgElement.classList.add('cursor-grabbing');
    if (e.cancelable) e.preventDefault(); // Prevent default drag behavior
  }

  function handlePointerMove(e: MouseEvent | TouchEvent) {
    if (!isDragging || !isZoomed) return;
    
    let clientX = 0;
    let clientY = 0;

    if ('touches' in e && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else if ('clientX' in e) {
        clientX = (e as MouseEvent).clientX;
        clientY = (e as MouseEvent).clientY;
    } else {
        return;
    }
    
    translateX = clientX - startX;
    translateY = clientY - startY;
    
    updateImageTransform();
    if (e.cancelable) e.preventDefault();
  }

  function handlePointerUp() {
    isDragging = false;
    if (imgElement) imgElement.classList.remove('cursor-grabbing');
  }

  function updateLightbox() {
    const images = lightboxImages.get();
    const index = currentIndex.get();
    const isOpen = isLightboxOpen.get();
    
    if (isOpen) {
        // Reset zoom whenever image changes or lightbox opens
        resetZoom();

        lightbox?.classList.remove('opacity-0', 'pointer-events-none');
        lightbox?.focus();
        // Prevent body scroll
        document.body.style.overflow = 'hidden';
        
        if (images[index]) {
            const img = images[index];
            if (imgElement) {
                // Preload adjacent images
                const nextIdx = (index + 1) % images.length;
                const prevIdx = (index - 1 + images.length) % images.length;
                new Image().src = images[nextIdx].src;
                new Image().src = images[prevIdx].src;

                imgElement.src = img.src;
                imgElement.alt = img.alt || img.title || 'Gallery image';
            }
            if (titleElement) titleElement.textContent = img.title || '';
            if (categoryElement) categoryElement.textContent = img.category || '';
            if (counterElement) counterElement.textContent = `${index + 1} / ${images.length}`;
            
            // Share Link Update (placeholder)
            if (shareLink) shareLink.href = `https://twitter.com/intent/tweet?text=${encodeURIComponent(img.title || '')}&url=${encodeURIComponent(window.location.href)}`;

            if (captionElement) {
                if (img.caption) {
                    captionElement.textContent = img.caption;
                    captionElement.classList.remove('hidden');
                } else {
                    captionElement.classList.add('hidden');
                }
            }

            if (exifElement) {
                // EXIF requires data passed from store. 
                // We need to update map logic below to include EXIF.
                // Assuming img.exif exists (we need to update mapping first)
                // Cast to any for now or update interface
                const exif = (img as any).exif;
                if (exif) {
                    exifElement.innerHTML = `
                        <span>${exif.camera || ''}</span>
                        <span>${exif.lens || ''}</span>
                        <span>${exif.iso ? 'ISO ' + exif.iso : ''}</span>
                        <span>${exif.aperture || ''}</span>
                        <span>${exif.shutter || ''}</span>
                    `;
                    exifElement.classList.remove('hidden');
                } else {
                    exifElement.classList.add('hidden');
                }
            }
            
            captionContainer?.classList.remove('opacity-0');
        }
    } else {
        lightbox?.classList.add('opacity-0', 'pointer-events-none');
        captionContainer?.classList.add('opacity-0');
        // Restore body scroll
        document.body.style.overflow = '';
    }
  }

  // Subscriptions
  isLightboxOpen.subscribe(updateLightbox);
  currentIndex.subscribe(updateLightbox);

  // Event Listeners
  closeBtn?.addEventListener('click', closeLightbox);
  prevBtn?.addEventListener('click', (e) => { e.stopPropagation(); prevImage(); });
  nextBtn?.addEventListener('click', (e) => { e.stopPropagation(); nextImage(); });
  
  // Click to toggle zoom
  imgElement?.addEventListener('click', (e) => {
    // Only toggle if not dragging (to distinguish click from drag release)
    if (!isDragging) {
        toggleZoom(e);
    }
  });

  // Dragging for Panning (Mouse + Touch)
  imgElement?.addEventListener('mousedown', handlePointerDown);
  window.addEventListener('mousemove', handlePointerMove);
  window.addEventListener('mouseup', handlePointerUp);
  
  imgElement?.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2 && e.touches[0] && e.touches[1]) {
        // Prepare for pinch
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        return;
    }
    handlePointerDown(e);
  }, { passive: false });
  
  window.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2 && initialDistance > 0 && e.touches[0] && e.touches[1]) {
        // Pinch Zoom Logic
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        
        const scaleChange = currentDistance / initialDistance;
        
        // Update scale with limits
        const newScale = currentScale * scaleChange;
        if (newScale >= 1 && newScale <= 4) {
             currentScale = newScale;
             updateImageTransform();
        }
        
        initialDistance = currentDistance; // Reset for continuous delta
        if (e.cancelable) e.preventDefault();
        return;
    }
    handlePointerMove(e);
  }, { passive: false });
  
  window.addEventListener('touchend', (e) => {
    handlePointerUp();
    if (e.touches.length < 2) {
        initialDistance = 0;
    }
  });

  // Click outside to close (click on backdrop)
  lightbox?.addEventListener('click', (e) => {
    // Check if click target is the container or the flex spacer
    if (e.target === lightbox) {
        closeLightbox();
    }
  });

  // Keyboard navigation
  document.addEventListener('keydown', (e) => {
    if (!isLightboxOpen.get()) return;

    switch(e.key) {
        case 'Escape': 
            closeLightbox(); 
            break;
        case 'ArrowRight': 
            if (!isZoomed) nextImage(); // Disable nav when zoomed to avoid conflict with pan
            break;
        case 'ArrowLeft': 
            if (!isZoomed) prevImage(); 
            break;
        case ' ':
            e.preventDefault(); 
            if (!isZoomed) nextImage(); 
            break;
    }
  });
  
  // Touch Gestures (Simple Swipe)
  let touchStartX = 0;
  let touchEndX = 0;
  
  lightbox?.addEventListener('touchstart', (e) => {
      // Don't swipe nav if zoomed
      if (isZoomed || e.changedTouches.length === 0) return;
      touchStartX = e.changedTouches[0].screenX;
  }, { passive: true });
  
  lightbox?.addEventListener('touchend', (e) => {
      if (isZoomed || e.changedTouches.length === 0) return;
      touchEndX = e.changedTouches[0].screenX;
      handleSwipe();
  }, { passive: true });
  
  function handleSwipe() {
      const threshold = 50;
      if (touchEndX < touchStartX - threshold) {
          nextImage();
      }
      if (touchEndX > touchStartX + threshold) {
          prevImage();
      }
  }
</script>
